// Generated using `moon info`, DON'T EDIT IT
package "enanandesu/symoon/src/number"

// Values
pub fn alternating_group(Int) -> PermutationGroup

pub fn bin_to_gray(String) -> String

pub fn binomial(Int, Int) -> Int

pub fn bitlist_from_subset(Array[Int], Array[Int]) -> String

pub fn bitlist_to_int(String) -> Int

pub fn carmichael(Int) -> Int

pub fn composite(Int) -> Int

pub fn compositepi(Int) -> Int

pub fn compositepi_alt(Int) -> Int

pub fn cycle_length((Int) -> Int, Int, nmax? : Int, values? : Bool) -> Int

pub fn cyclic_group(Int) -> PermutationGroup

pub fn dihedral_group(Int) -> PermutationGroup

pub fn diophantine_linear(Int, Int, Int) -> (Int, Int, Int, Int)

pub fn divisor_count(Int) -> Int

pub fn divisor_sigma(Int, power? : Int) -> Int

pub fn divisors(Int) -> Array[Int]

pub fn factorint(Int) -> Map[Int, Int]

pub fn fibonacci(Int) -> Int

pub fn gcd(Int, Int) -> Int

pub fn gcdex(Int, Int) -> (Int, Int, Int)

pub fn generate_gray(Int, start? : Int) -> Array[String]

pub fn get_subset_from_bitstring(Array[Int], String) -> Array[Int]

pub fn gray_to_bin(String) -> String

pub fn graycode_subsets(Array[Int]) -> Array[Array[Int]]

pub fn igcd(Int, Int) -> Int

pub fn ilcm(Int, Int) -> Int

pub fn is_quad_residue(Int, Int) -> Bool

pub fn isprime(Int) -> Bool

pub fn iterate_binary(Array[Int]) -> Array[Array[Int]]

pub fn iterate_graycode(Array[Int]) -> Array[Array[Int]]

pub fn jacobi_symbol(Int, Int) -> Int

pub fn kronecker_symbol(Int, Int) -> Int

pub fn ksubsets(Array[Int], Int) -> Array[Array[Int]]

pub fn lcm(Int, Int) -> Int

pub fn legendre_symbol(Int, Int) -> Int

pub fn lucas(Int) -> Int

pub fn mobius(Int) -> Int

pub fn mod_inverse(Int, Int) -> Int

pub fn multiplicity(Int, Int) -> Int

pub fn n_order(Int, Int) -> Int

pub fn next_binary(Array[Int], Array[Int], delta? : Int) -> Array[Int]

pub fn next_gray(Array[Int], Array[Int], delta? : Int) -> Array[Int]

pub fn nextprime(Int) -> Int

pub fn nodes_from_edges(Array[(Int, Int)]) -> Int

pub fn npartitions(Int) -> Int

pub fn nt_divisor_count(Int) -> Int

pub fn nt_divisor_sigma(Int, power? : Int) -> Int

pub fn nt_divisors(Int) -> Array[Int]

pub fn nt_factorint(Int) -> Map[Int, Int]

pub fn nt_first_n_primes(Int) -> Array[Int]

pub fn nt_gcd(Int, Int) -> Int

pub fn nt_gcd_ex(Int, Int) -> (Int, Int, Int)

pub fn nt_is_divisible_by(Int, Int) -> Bool

pub fn nt_is_divisible_by_all(Int, Array[Int]) -> Bool

pub fn nt_is_divisible_by_any(Int, Array[Int]) -> Bool

pub fn nt_is_prime(Int) -> Bool

pub fn nt_lcm(Int, Int) -> Int

pub fn nt_multiplicity(Int, Int) -> Int

pub fn nt_next_prime(Int) -> Int

pub fn nt_nth_prime(Int) -> Int

pub fn nt_prev_prime(Int) -> Int

pub fn nt_prime(Int) -> Int

pub fn nt_prime_factor_list(Int) -> Array[Int]

pub fn nt_prime_factors(Int) -> Array[(Int, Int)]

pub fn nt_prime_pi(Int) -> Int

pub fn nt_prime_range(Int, Int) -> Array[Int]

pub fn nt_primes_up_to(Int) -> Array[Int]

pub fn nt_rand_prime(Int, Int, seed? : Int) -> Int

pub fn nt_totient(Int) -> Int

pub fn pell_solutions(Int, count? : Int) -> Array[(Int, Int)]

pub fn perfect_power(Int) -> Bool

pub fn pollard_pm1(Int) -> Array[(Int, Int)]

pub fn pollard_rho(Int) -> Array[(Int, Int)]

pub fn prev_binary(Array[Int], Array[Int], delta? : Int) -> Array[Int]

pub fn prev_gray(Array[Int], Array[Int], delta? : Int) -> Array[Int]

pub fn prevprime(Int) -> Int

pub fn prime(Int) -> Int

pub fn primefactors(Int) -> Array[Int]

pub fn primenu(Int) -> Int

pub fn primeomega(Int) -> Int

pub fn primepi(Int) -> Int

pub fn primerange(Int, Int) -> Array[Int]

pub fn primorial(Int, nth? : Bool) -> Int

pub fn pythagorean_triples(Int) -> Array[(Int, Int, Int)]

pub fn quadratic_residues(Int) -> Array[Int]

pub fn random_bitstring(Int, seed? : Int) -> String

pub fn random_integer_partition(Int, seed? : Int) -> Array[Int]

pub fn randprime(Int, Int, seed? : Int) -> Int

pub fn rank_binary(Array[Int], Array[Int]) -> Int

pub fn rank_gray(Array[Int], Array[Int]) -> Int

pub fn rank_lexicographic(Array[Int], Array[Int]) -> Int

pub fn rgs_enum(Int) -> Int

pub fn rgs_generalized(Int) -> Array[Array[Int]]

pub fn rgs_rank(Array[Int]) -> Int

pub fn rgs_unrank(Int, Int) -> Array[Int]

pub fn solve_congruence(Array[(Int, Int)]) -> (Int, Int)

pub fn sort_edges(Array[(Int, Int)]) -> Array[(Int, Int)]

pub fn sqrt_mod(Int, Int) -> Array[Int]

pub fn stirling(Int, Int, kind? : Int) -> Int

pub fn subset_from_bitlist(Array[Int], String) -> Array[Int]

pub fn subset_indices(Array[Int], Array[Int]) -> Array[Int]

pub fn sum_of_squares(Int) -> Int

pub fn symmetric_group(Int) -> PermutationGroup

pub fn to_prufer(Array[(Int, Int)], Int) -> Array[Int]

pub fn to_tree(Array[Int]) -> Array[(Int, Int)]

pub fn totient(Int) -> Int

pub fn trailing(Int) -> Int

pub fn unrank_binary(Int, Array[Int]) -> Array[Int]

pub fn unrank_gray(Int, Array[Int]) -> Array[Int]

pub fn unrank_lexicographic(Int, Array[Int]) -> Array[Int]

// Errors

// Types and methods
pub struct GrayCode {
  n : Int
  rank : Int
}
pub fn GrayCode::current(Self) -> String
pub fn GrayCode::n(Self) -> Int
pub fn GrayCode::new(Int, start? : Int, rank? : Int) -> Self
pub fn GrayCode::next(Self, delta? : Int) -> Self
pub fn GrayCode::rank(Self) -> Int
pub fn GrayCode::selections(Self) -> Int
pub fn GrayCode::skip(Self, delta? : Int) -> Self
pub fn GrayCode::unrank(Int, Int) -> Self

pub struct IntegerPartition {
  parts : Array[Int]
}
pub fn IntegerPartition::as_dict(Self) -> Map[Int, Int]
pub fn IntegerPartition::as_ferrers(Self, char? : String) -> String
pub fn IntegerPartition::conjugate(Self) -> Self
pub fn IntegerPartition::new(Array[Int]) -> Self
pub fn IntegerPartition::next_lex(Self) -> Self
pub fn IntegerPartition::parts(Self) -> Array[Int]
pub fn IntegerPartition::prev_lex(Self) -> Self

pub struct Partition {
  blocks : Array[Array[Int]]
  rgs : Array[Int]
}
pub fn Partition::from_rgs(Array[Int], Array[Int]) -> Self
pub fn Partition::partition(Self) -> Array[Array[Int]]
pub fn Partition::rank(Self) -> Int
pub fn Partition::rgs(Self) -> Array[Int]
pub fn Partition::sort_key(Self) -> String

pub struct Permutation {
  mapping : Array[Int]
}
pub fn Permutation::apply(Self, Int) -> Int
pub fn Permutation::array_form(Self) -> Array[Int]
pub fn Permutation::ascents(Self) -> Array[Int]
pub fn Permutation::commutator(Self, Self) -> Self
pub fn Permutation::commutes_with(Self, Self) -> Bool
pub fn Permutation::compose(Self, Self) -> Self
pub fn Permutation::cycle_structure(Self) -> Array[Int]
pub fn Permutation::cycles(Self) -> Array[Array[Int]]
pub fn Permutation::cyclic_form(Self) -> String
pub fn Permutation::descents(Self) -> Array[Int]
pub fn Permutation::identity(Int) -> Self
pub fn Permutation::inverse(Self) -> Self
pub fn Permutation::length(Self) -> Int
pub fn Permutation::new(Array[Int]) -> Self
pub fn Permutation::next_lex(Self) -> Self
pub fn Permutation::parity(Self) -> Int
pub fn Permutation::prev_lex(Self) -> Self
pub fn Permutation::rank_lex(Self) -> Int
pub fn Permutation::unrank_lex(Int, Int) -> Self

pub struct PermutationGroup {
  generators : Array[Permutation]
  degree : Int
}
pub fn PermutationGroup::abelian_invariants(Self) -> Array[Int]
pub fn PermutationGroup::base(Self) -> Array[Int]
pub fn PermutationGroup::basic_data(Self) -> (Array[Array[Int]], Array[Array[Permutation]], Array[Map[Int, Permutation]])
pub fn PermutationGroup::basic_orbits(Self) -> Array[Array[Int]]
pub fn PermutationGroup::basic_stabilizers(Self) -> Array[Array[Permutation]]
pub fn PermutationGroup::basic_transversals(Self) -> Array[Map[Int, Permutation]]
pub fn PermutationGroup::identity(Self) -> Permutation
pub fn PermutationGroup::new(Array[Permutation]) -> Self
pub fn PermutationGroup::order(Self) -> Int
pub fn PermutationGroup::schreier_sims(Self) -> Self

pub struct Polyhedron {
  base_corners : Array[Int]
  base_faces : Array[Array[Int]]
  pgroup : Array[Permutation]
  current : Permutation
}
pub fn Polyhedron::array_form(Self) -> Array[Int]
pub fn Polyhedron::corners(Self) -> Array[Int]
pub fn Polyhedron::cyclic_form(Self) -> String
pub fn Polyhedron::edges(Self) -> Array[(Int, Int)]
pub fn Polyhedron::faces(Self) -> Array[Array[Int]]
pub fn Polyhedron::new(Array[Int], faces? : Array[Array[Int]], pgroup? : Array[Permutation]) -> Self
pub fn Polyhedron::reset(Self) -> Self
pub fn Polyhedron::rotate(Self, Permutation) -> Self
pub fn Polyhedron::rotate_by_index(Self, Int) -> Self
pub fn Polyhedron::size(Self) -> Int
pub fn Polyhedron::vertices(Self) -> Array[Int]

pub struct Prufer {
  seq : Array[Int]
}
pub fn Prufer::edges(Self) -> Array[(Int, Int)]
pub fn Prufer::new(Array[Int]) -> Self
pub fn Prufer::next(Self, delta? : Int) -> Self
pub fn Prufer::nodes(Self) -> Array[Int]
pub fn Prufer::prev(Self, delta? : Int) -> Self
pub fn Prufer::prufer_rank(Self) -> Int
pub fn Prufer::prufer_repr(Self) -> Array[Int]
pub fn Prufer::rank(Self) -> Int
pub fn Prufer::size(Self) -> Int
pub fn Prufer::tree_repr(Self) -> Array[(Int, Int)]
pub fn Prufer::unrank(Int, Int) -> Self

pub struct Sieve {
  primes : Array[Int]
  limit : Int
}
pub fn Sieve::extend(Self, Int) -> Self
pub fn Sieve::new() -> Self
pub fn Sieve::primerange(Self, Int, Int) -> Array[Int]
pub fn Sieve::primes(Self) -> Array[Int]

pub struct Subset {
  subset : Array[Int]
  superset : Array[Int]
}
pub fn Subset::cardinality(Self) -> Int
pub fn Subset::new(Array[Int], Array[Int]) -> Self
pub fn Subset::size(Self) -> Int
pub fn Subset::subset(Self) -> Array[Int]
pub fn Subset::superset(Self) -> Array[Int]
pub fn Subset::superset_size(Self) -> Int

// Type aliases

// Traits


// Generated using `moon info`, DON'T EDIT IT
package "enanandesu/symoon/src/number"

// Values
pub fn binomial(Int, Int) -> Int

pub fn carmichael(Int) -> Int

pub fn diophantine_linear(Int, Int, Int) -> (Int, Int, Int, Int)

pub fn divisor_count(Int) -> Int

pub fn divisor_sigma(Int, power? : Int) -> Int

pub fn divisors(Int) -> Array[Int]

pub fn factorint(Int) -> Map[Int, Int]

pub fn fibonacci(Int) -> Int

pub fn gcd(Int, Int) -> Int

pub fn gcdex(Int, Int) -> (Int, Int, Int)

pub fn igcd(Int, Int) -> Int

pub fn ilcm(Int, Int) -> Int

pub fn is_quad_residue(Int, Int) -> Bool

pub fn isprime(Int) -> Bool

pub fn jacobi_symbol(Int, Int) -> Int

pub fn kronecker_symbol(Int, Int) -> Int

pub fn lcm(Int, Int) -> Int

pub fn legendre_symbol(Int, Int) -> Int

pub fn lucas(Int) -> Int

pub fn mobius(Int) -> Int

pub fn mod_inverse(Int, Int) -> Int

pub fn multiplicity(Int, Int) -> Int

pub fn n_order(Int, Int) -> Int

pub fn nextprime(Int) -> Int

pub fn npartitions(Int) -> Int

pub fn nt_divisor_count(Int) -> Int

pub fn nt_divisor_sigma(Int, power? : Int) -> Int

pub fn nt_divisors(Int) -> Array[Int]

pub fn nt_factorint(Int) -> Map[Int, Int]

pub fn nt_first_n_primes(Int) -> Array[Int]

pub fn nt_gcd(Int, Int) -> Int

pub fn nt_gcd_ex(Int, Int) -> (Int, Int, Int)

pub fn nt_is_divisible_by(Int, Int) -> Bool

pub fn nt_is_divisible_by_all(Int, Array[Int]) -> Bool

pub fn nt_is_divisible_by_any(Int, Array[Int]) -> Bool

pub fn nt_is_prime(Int) -> Bool

pub fn nt_lcm(Int, Int) -> Int

pub fn nt_multiplicity(Int, Int) -> Int

pub fn nt_next_prime(Int) -> Int

pub fn nt_nth_prime(Int) -> Int

pub fn nt_prev_prime(Int) -> Int

pub fn nt_prime(Int) -> Int

pub fn nt_prime_factor_list(Int) -> Array[Int]

pub fn nt_prime_factors(Int) -> Array[(Int, Int)]

pub fn nt_prime_pi(Int) -> Int

pub fn nt_prime_range(Int, Int) -> Array[Int]

pub fn nt_primes_up_to(Int) -> Array[Int]

pub fn nt_rand_prime(Int, Int, seed? : Int) -> Int

pub fn nt_totient(Int) -> Int

pub fn pell_solutions(Int, count? : Int) -> Array[(Int, Int)]

pub fn prevprime(Int) -> Int

pub fn prime(Int) -> Int

pub fn primenu(Int) -> Int

pub fn primeomega(Int) -> Int

pub fn primepi(Int) -> Int

pub fn primerange(Int, Int) -> Array[Int]

pub fn pythagorean_triples(Int) -> Array[(Int, Int, Int)]

pub fn quadratic_residues(Int) -> Array[Int]

pub fn random_integer_partition(Int, seed? : Int) -> Array[Int]

pub fn rgs_enum(Int) -> Int

pub fn rgs_generalized(Int) -> Array[Array[Int]]

pub fn rgs_rank(Array[Int]) -> Int

pub fn rgs_unrank(Int, Int) -> Array[Int]

pub fn solve_congruence(Array[(Int, Int)]) -> (Int, Int)

pub fn sqrt_mod(Int, Int) -> Array[Int]

pub fn stirling(Int, Int, kind? : Int) -> Int

pub fn sum_of_squares(Int) -> Int

pub fn totient(Int) -> Int

// Errors

// Types and methods
pub struct IntegerPartition {
  parts : Array[Int]
}
pub fn IntegerPartition::as_dict(Self) -> Map[Int, Int]
pub fn IntegerPartition::as_ferrers(Self, char? : String) -> String
pub fn IntegerPartition::conjugate(Self) -> Self
pub fn IntegerPartition::new(Array[Int]) -> Self
pub fn IntegerPartition::next_lex(Self) -> Self
pub fn IntegerPartition::parts(Self) -> Array[Int]
pub fn IntegerPartition::prev_lex(Self) -> Self

pub struct Partition {
  blocks : Array[Array[Int]]
  rgs : Array[Int]
}
pub fn Partition::from_rgs(Array[Int], Array[Int]) -> Self
pub fn Partition::partition(Self) -> Array[Array[Int]]
pub fn Partition::rank(Self) -> Int
pub fn Partition::rgs(Self) -> Array[Int]
pub fn Partition::sort_key(Self) -> String

pub struct Permutation {
  mapping : Array[Int]
}
pub fn Permutation::apply(Self, Int) -> Int
pub fn Permutation::array_form(Self) -> Array[Int]
pub fn Permutation::ascents(Self) -> Array[Int]
pub fn Permutation::commutator(Self, Self) -> Self
pub fn Permutation::commutes_with(Self, Self) -> Bool
pub fn Permutation::compose(Self, Self) -> Self
pub fn Permutation::cycle_structure(Self) -> Array[Int]
pub fn Permutation::cycles(Self) -> Array[Array[Int]]
pub fn Permutation::cyclic_form(Self) -> String
pub fn Permutation::descents(Self) -> Array[Int]
pub fn Permutation::identity(Int) -> Self
pub fn Permutation::inverse(Self) -> Self
pub fn Permutation::length(Self) -> Int
pub fn Permutation::new(Array[Int]) -> Self
pub fn Permutation::next_lex(Self) -> Self
pub fn Permutation::parity(Self) -> Int
pub fn Permutation::prev_lex(Self) -> Self
pub fn Permutation::rank_lex(Self) -> Int
pub fn Permutation::unrank_lex(Int, Int) -> Self

pub struct PermutationGroup {
  generators : Array[Permutation]
  degree : Int
}
pub fn PermutationGroup::abelian_invariants(Self) -> Array[Int]
pub fn PermutationGroup::base(Self) -> Array[Int]
pub fn PermutationGroup::basic_data(Self) -> (Array[Array[Int]], Array[Array[Permutation]], Array[Map[Int, Permutation]])
pub fn PermutationGroup::basic_orbits(Self) -> Array[Array[Int]]
pub fn PermutationGroup::basic_stabilizers(Self) -> Array[Array[Permutation]]
pub fn PermutationGroup::basic_transversals(Self) -> Array[Map[Int, Permutation]]
pub fn PermutationGroup::identity(Self) -> Permutation
pub fn PermutationGroup::new(Array[Permutation]) -> Self
pub fn PermutationGroup::order(Self) -> Int
pub fn PermutationGroup::schreier_sims(Self) -> Self

// Type aliases

// Traits


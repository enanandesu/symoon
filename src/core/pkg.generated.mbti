// Generated using `moon info`, DON'T EDIT IT
package "enanandesu/symoon/src/core"

// Values
pub fn abs(Expr) -> Expr

pub fn acos(Expr) -> Expr

pub fn acosh(Expr) -> Expr

pub fn add(Expr, Expr) -> Expr

pub fn asin(Expr) -> Expr

pub fn asinh(Expr) -> Expr

pub fn atan(Expr) -> Expr

pub fn atanh(Expr) -> Expr

pub fn classify_indeterminate(Expr, String, Expr) -> IndeterminateForm?

pub fn coefficient_of(Expr, String, degree? : Int) -> Expr

pub fn cos(Expr) -> Expr

pub fn cosh(Expr) -> Expr

pub fn count_ops(Expr) -> Double

pub fn default_rational_constants() -> Array[RationalConstant]

pub fn differentiate(Expr, String, order? : Int) -> Expr

pub fn div(Expr, Expr) -> Expr

pub fn double(Double) -> Expr

pub fn evaluate(Expr, (String) -> Double?) -> Result[Double, SymbolicError]

pub fn exp(Expr) -> Expr

pub fn int(Int) -> Expr

pub fn leading_coefficient(Expr, String) -> Expr

pub fn limit(Expr, String, Expr, dir? : LimitDirection) -> LimitResult

pub fn limit_left(Expr, String, Expr) -> LimitResult

pub fn limit_right(Expr, String, Expr) -> LimitResult

pub fn log(Expr) -> Expr

pub fn match_expr(Pattern, Expr) -> PatternBindings?

pub fn matches(Pattern, Expr) -> Bool

pub fn mul(Expr, Expr) -> Expr

pub fn nan() -> Expr

pub fn neg(Expr) -> Expr

pub fn neg_infinity() -> Expr

pub fn pattern_all_of(Array[Pattern]) -> Pattern

pub fn pattern_any() -> Pattern

pub fn pattern_binary(Pattern, Pattern, op? : BinaryOp?) -> Pattern

pub fn pattern_call(name? : String?, Array[Pattern]) -> Pattern

pub fn pattern_double(value? : Double?) -> Pattern

pub fn pattern_exact(Expr) -> Pattern

pub fn pattern_guard(Pattern, (Expr, PatternBindings) -> Bool) -> Pattern

pub fn pattern_guarded(String, (Expr) -> Bool) -> Pattern

pub fn pattern_int(value? : Int?) -> Pattern

pub fn pattern_one_of(Array[Pattern]) -> Pattern

pub fn pattern_product(Array[Pattern]) -> Pattern

pub fn pattern_sum(Array[Pattern]) -> Pattern

pub fn pattern_symbol(name? : String?) -> Pattern

pub fn pattern_unary(Pattern, op? : UnaryOp?) -> Pattern

pub fn pattern_wildcard(String) -> Pattern

pub fn pos_infinity() -> Expr

pub fn pow(Expr, Expr) -> Expr

pub fn rationalize_expr(Expr, constants? : Array[RationalConstant], tolerance? : Double, full? : Bool, rational? : Bool, rational_conversion? : String) -> Expr

pub fn rewrite(Expr, Array[RewriteRule], max_iterations? : Int) -> Expr

pub fn rewrite_once(Expr, Array[RewriteRule]) -> Expr?

pub fn simplify(Expr, ratio? : Double, measure? : (Expr) -> Double, rational? : Bool, inverse? : Bool, doit? : Bool) -> Expr

pub fn sin(Expr) -> Expr

pub fn sinh(Expr) -> Expr

pub fn solve_linear_equation(Expr, Expr, String) -> Expr

pub fn solve_linear_system(Expr, Expr, Expr, Expr, String, String) -> (Expr, Expr)

pub fn solve_linear_system_n(Array[(Expr, Expr)], Array[String]) -> Array[Expr]

pub fn sub(Expr, Expr) -> Expr

pub fn sym(String) -> Expr

pub fn tan(Expr) -> Expr

pub fn tanh(Expr) -> Expr

pub fn to_latex(Expr) -> String

pub fn try_apply_rule(RewriteRule, Expr) -> Expr?

// Errors

// Types and methods
pub enum BinaryOp {
  Add
  Sub
  Mul
  Div
  Pow
}
pub fn BinaryOp::copy(Self) -> Self
pub impl Eq for BinaryOp
pub impl Hash for BinaryOp
pub impl Show for BinaryOp

pub enum ConstantLiteral {
  Integer(Int)
  Float(Double)
  PosInfinity
  NegInfinity
  NaN
}
pub impl Eq for ConstantLiteral
pub impl Show for ConstantLiteral

pub enum Expr {
  Constant(ConstantLiteral)
  Symbol(Symbol)
  Unary(UnaryOp, Expr)
  Binary(BinaryOp, Expr, Expr)
  FunctionCall(String, Array[Expr])
}
pub fn Expr::copy(Self) -> Self
pub impl Add for Expr
pub impl Div for Expr
pub impl Eq for Expr
pub impl Mul for Expr
pub impl Neg for Expr
pub impl Show for Expr
pub impl Sub for Expr

pub enum IndeterminateForm {
  ZeroOverZero
  InfinityOverInfinity
  ZeroTimesInfinity
  InfinityMinusInfinity
  OnePowerInfinity
  ZeroPowerZero
  InfinityPowerZero
  Oscillatory
}
pub impl Eq for IndeterminateForm
pub impl Show for IndeterminateForm

pub enum LimitDirection {
  Both
  FromLeft
  FromRight
}
pub impl Eq for LimitDirection
pub impl Show for LimitDirection

pub enum LimitResult {
  Value(Expr)
  PosInf
  NegInf
  Divergent
  Unknown
}
pub impl Eq for LimitResult
pub impl Show for LimitResult

pub enum Pattern {
  Any
  Wildcard(String)
  GuardedWildcard(String, (Expr) -> Bool)
  Exact(Expr)
  Symbol(String?)
  IntLiteral(Int?)
  DoubleLiteral(Double?)
  Unary(UnaryOp?, Pattern)
  Binary(BinaryOp?, Pattern, Pattern)
  Commutative(BinaryOp, Array[Pattern])
  FunctionCall(String?, Array[Pattern])
  OneOf(Array[Pattern])
  All(Array[Pattern])
  Guard(Pattern, (Expr, PatternBindings) -> Bool)
}
pub fn Pattern::copy(Self) -> Self

pub struct PatternBindings {
  entries : Map[String, Expr]
}
pub fn PatternBindings::bind_expr(Self, String, Expr) -> Self?
pub fn PatternBindings::contains(Self, String) -> Bool
pub fn PatternBindings::copy(Self) -> Self
pub fn PatternBindings::expect(Self, String) -> Expr
pub fn PatternBindings::get(Self, String) -> Expr?
pub fn PatternBindings::is_empty(Self) -> Bool
pub fn PatternBindings::len(Self) -> Int
pub fn PatternBindings::new() -> Self
pub fn PatternBindings::to_array(Self) -> Array[(String, Expr)]

pub struct RationalConstant {
  symbol : Expr
  numeric : Double?
}
pub fn RationalConstant::copy(Self) -> Self
pub fn RationalConstant::new(Expr, Double?) -> Self

pub struct RewriteRule {
  pattern : Pattern
  builder : (PatternBindings) -> Expr
  condition : ((PatternBindings) -> Bool)?
}
pub fn RewriteRule::new(Pattern, (PatternBindings) -> Expr) -> Self
pub fn RewriteRule::with_condition(Self, (PatternBindings) -> Bool) -> Self

pub struct Symbol {
  name : String
}
pub fn Symbol::copy(Self) -> Self
pub fn Symbol::new(String) -> Self
pub impl Eq for Symbol
pub impl Hash for Symbol
pub impl Show for Symbol

pub enum SymbolicError {
  UndefinedSymbol(String)
  DomainViolation(String, String)
  UnsupportedOperation(String)
}
pub fn SymbolicError::copy(Self) -> Self
pub impl Eq for SymbolicError
pub impl Show for SymbolicError

pub enum UnaryOp {
  Neg
  Sin
  Cos
  Tan
  Asin
  Acos
  Atan
  Sinh
  Cosh
  Tanh
  Asinh
  Acosh
  Atanh
  Exp
  Log
  Abs
}
pub fn UnaryOp::copy(Self) -> Self
pub impl Eq for UnaryOp
pub impl Hash for UnaryOp
pub impl Show for UnaryOp

// Type aliases

// Traits


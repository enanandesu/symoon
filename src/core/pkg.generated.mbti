// Generated using `moon info`, DON'T EDIT IT
package "enanandesu/symoon/src/core"

// Values
fn abs(Expr) -> Expr

fn acos(Expr) -> Expr

fn acosh(Expr) -> Expr

fn add(Expr, Expr) -> Expr

fn asin(Expr) -> Expr

fn asinh(Expr) -> Expr

fn atan(Expr) -> Expr

fn atanh(Expr) -> Expr

fn cos(Expr) -> Expr

fn cosh(Expr) -> Expr

fn count_ops(Expr) -> Double

fn default_rational_constants() -> Array[RationalConstant]

fn differentiate(Expr, String) -> Expr

fn div(Expr, Expr) -> Expr

fn double(Double) -> Expr

fn evaluate(Expr, (String) -> Double?) -> Result[Double, SymbolicError]

fn exp(Expr) -> Expr

fn int(Int) -> Expr

fn log(Expr) -> Expr

fn match_expr(Pattern, Expr) -> PatternBindings?

fn matches(Pattern, Expr) -> Bool

fn mul(Expr, Expr) -> Expr

fn neg(Expr) -> Expr

fn pattern_all_of(Array[Pattern]) -> Pattern

fn pattern_any() -> Pattern

fn pattern_binary(Pattern, Pattern, op? : BinaryOp?) -> Pattern

fn pattern_call(name? : String?, Array[Pattern]) -> Pattern

fn pattern_double(value? : Double?) -> Pattern

fn pattern_exact(Expr) -> Pattern

fn pattern_guard(Pattern, (Expr, PatternBindings) -> Bool) -> Pattern

fn pattern_guarded(String, (Expr) -> Bool) -> Pattern

fn pattern_int(value? : Int?) -> Pattern

fn pattern_one_of(Array[Pattern]) -> Pattern

fn pattern_symbol(name? : String?) -> Pattern

fn pattern_unary(Pattern, op? : UnaryOp?) -> Pattern

fn pattern_wildcard(String) -> Pattern

fn pow(Expr, Expr) -> Expr

fn rationalize_expr(Expr, constants? : Array[RationalConstant], tolerance? : Double, full? : Bool, rational? : Bool, rational_conversion? : String) -> Expr

fn rewrite(Expr, Array[RewriteRule], max_iterations? : Int) -> Expr

fn rewrite_once(Expr, Array[RewriteRule]) -> Expr?

fn simplify(Expr, ratio? : Double, measure? : (Expr) -> Double, rational? : Bool, inverse? : Bool, doit? : Bool) -> Expr

fn sin(Expr) -> Expr

fn sinh(Expr) -> Expr

fn sub(Expr, Expr) -> Expr

fn sym(String) -> Expr

fn tan(Expr) -> Expr

fn tanh(Expr) -> Expr

fn try_apply_rule(RewriteRule, Expr) -> Expr?

// Errors

// Types and methods
pub enum BinaryOp {
  Add
  Sub
  Mul
  Div
  Pow
}
fn BinaryOp::copy(Self) -> Self
impl Eq for BinaryOp
impl Hash for BinaryOp
impl Show for BinaryOp

pub enum Expr {
  Int(Int)
  Double(Double)
  Symbol(Symbol)
  Unary(UnaryOp, Expr)
  Binary(BinaryOp, Expr, Expr)
  FunctionCall(String, Array[Expr])
}
fn Expr::copy(Self) -> Self
impl Add for Expr
impl Div for Expr
impl Eq for Expr
impl Mul for Expr
impl Neg for Expr
impl Show for Expr
impl Sub for Expr

pub enum Pattern {
  Any
  Wildcard(String)
  GuardedWildcard(String, (Expr) -> Bool)
  Exact(Expr)
  Symbol(String?)
  IntLiteral(Int?)
  DoubleLiteral(Double?)
  Unary(UnaryOp?, Pattern)
  Binary(BinaryOp?, Pattern, Pattern)
  FunctionCall(String?, Array[Pattern])
  OneOf(Array[Pattern])
  All(Array[Pattern])
  Guard(Pattern, (Expr, PatternBindings) -> Bool)
}
fn Pattern::copy(Self) -> Self

pub struct PatternBindings {
  entries : Array[(String, Expr)]
}
fn PatternBindings::bind_expr(Self, String, Expr) -> Self?
fn PatternBindings::contains(Self, String) -> Bool
fn PatternBindings::copy(Self) -> Self
fn PatternBindings::get(Self, String) -> Expr?
fn PatternBindings::is_empty(Self) -> Bool
fn PatternBindings::len(Self) -> Int
fn PatternBindings::new() -> Self
fn PatternBindings::to_array(Self) -> Array[(String, Expr)]

pub struct RationalConstant {
  symbol : Expr
  numeric : Double?
}
fn RationalConstant::copy(Self) -> Self
fn RationalConstant::new(Expr, Double?) -> Self

pub struct RewriteRule {
  pattern : Pattern
  builder : (PatternBindings) -> Expr
  condition : ((PatternBindings) -> Bool)?
}
fn RewriteRule::new(Pattern, (PatternBindings) -> Expr) -> Self
fn RewriteRule::with_condition(Self, (PatternBindings) -> Bool) -> Self

pub struct Symbol {
  name : String
}
fn Symbol::copy(Self) -> Self
fn Symbol::new(String) -> Self
impl Eq for Symbol
impl Hash for Symbol
impl Show for Symbol

pub enum SymbolicError {
  UndefinedSymbol(String)
  DomainViolation(String, String)
  UnsupportedOperation(String)
}
fn SymbolicError::copy(Self) -> Self
impl Eq for SymbolicError
impl Show for SymbolicError

pub enum UnaryOp {
  Neg
  Sin
  Cos
  Tan
  Asin
  Acos
  Atan
  Sinh
  Cosh
  Tanh
  Asinh
  Acosh
  Atanh
  Exp
  Log
  Abs
}
fn UnaryOp::copy(Self) -> Self
impl Eq for UnaryOp
impl Hash for UnaryOp
impl Show for UnaryOp

// Type aliases

// Traits

